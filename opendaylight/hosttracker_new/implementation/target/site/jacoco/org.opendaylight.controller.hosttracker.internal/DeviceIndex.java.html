<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DeviceIndex.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hosttracker_new.implementation</a> &gt; <a href="index.html" class="el_package">org.opendaylight.controller.hosttracker.internal</a> &gt; <span class="el_source">DeviceIndex.java</span></div><h1>DeviceIndex.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012 Big Switch Networks, Inc.
 *
 * Licensed under the Eclipse Public License, Version 1.0 (the
 * &quot;License&quot;); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 *      http://www.eclipse.org/legal/epl-v10.html
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License.
 *
 * This file incorporates work covered by the following copyright and
 * permission notice:
 *
 *    Originally created by David Erickson, Stanford University
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the
 *    License. You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing,
 *    software distributed under the License is distributed on an &quot;AS
 *    IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 *    express or implied. See the License for the specific language
 *    governing permissions and limitations under the License.
 */

package org.opendaylight.controller.hosttracker.internal;

import java.util.Collection;
import java.util.EnumSet;
import java.util.Iterator;

import org.opendaylight.controller.hosttracker.Entity;
import org.opendaylight.controller.hosttracker.IDeviceService.DeviceField;

/**
 * An index that maps key fields of an entity to device keys
 */
public abstract class DeviceIndex {
    /**
     * The key fields for this index
     */
    protected EnumSet&lt;DeviceField&gt; keyFields;

    /**
     * Construct a new device index using the provided key fields
     *
     * @param keyFields
     *            the key fields to use
     */
    public DeviceIndex(EnumSet&lt;DeviceField&gt; keyFields) {
<span class="nc" id="L59">        super();</span>
<span class="nc" id="L60">        this.keyFields = keyFields;</span>
<span class="nc" id="L61">    }</span>

    /**
     * Find all device keys in the index that match the given entity on all the
     * key fields for this index
     *
     * @param e
     *            the entity to search for
     * @return an iterator over device keys
     */
    public abstract Iterator&lt;Long&gt; queryByEntity(Entity entity);

    /**
     * Get all device keys in the index. If certain devices exist multiple
     * times, then these devices may be returned multiple times
     *
     * @return an iterator over device keys
     */
    public abstract Iterator&lt;Long&gt; getAll();

    /**
     * Attempt to update an index with the entities in the provided
     * {@link Device}. If the update fails because of a concurrent update, will
     * return false.
     *
     * @param device
     *            the device to update
     * @param deviceKey
     *            the device key for the device
     * @return true if the update succeeded, false otherwise.
     */
    public abstract boolean updateIndex(Device device, Long deviceKey);

    /**
     * Add a mapping from the given entity to the given device key. This update
     * will not fail because of a concurrent update
     *
     * @param device
     *            the device to update
     * @param deviceKey
     *            the device key for the device
     */
    public abstract void updateIndex(Entity entity, Long deviceKey);

    /**
     * Remove the entry for the given entity
     *
     * @param entity
     *            the entity to remove
     */
    public abstract void removeEntity(Entity entity);

    /**
     * Remove the given device key from the index for the given entity
     *
     * @param entity
     *            the entity to search for
     * @param deviceKey
     *            the key to remove
     */
    public abstract void removeEntity(Entity entity, Long deviceKey);

    /**
     * Remove the give device from the index only if this the collection of
     * others does not contain an entity that is identical on all the key fields
     * for this index.
     *
     * @param entity
     *            the entity to search for
     * @param deviceKey
     *            the key to remove
     * @param others
     *            the others against which to check
     */
    public void removeEntityIfNeeded(Entity entity, Long deviceKey,
            Collection&lt;Entity&gt; others) {
<span class="nc" id="L137">        IndexedEntity ie = new IndexedEntity(keyFields, entity);</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">        for (Entity o : others) {</span>
<span class="nc" id="L139">            IndexedEntity oio = new IndexedEntity(keyFields, o);</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">            if (oio.equals(ie))</span>
<span class="nc" id="L141">                return;</span>
        }

<span class="nc" id="L144">        Iterator&lt;Long&gt; keyiter = this.queryByEntity(entity);</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">        while (keyiter.hasNext()) {</span>
<span class="nc" id="L146">            Long key = keyiter.next();</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">            if (key.equals(deviceKey)) {</span>
<span class="nc" id="L148">                removeEntity(entity, deviceKey);</span>
<span class="nc" id="L149">                break;</span>
            }
        }
<span class="nc" id="L152">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://jacoco.org">JaCoCo</a> 0.5.3.201107060350</span></div></body></html>